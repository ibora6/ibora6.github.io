[{"content":"Yaml简介 YAML是一种人性化、跨语言、基于 Unicode 的数据序列化语言，它围绕动态编程语言的常见本机数据类型而设计。它对于从配置文件到 Internet 消息传递到对象持久性再到数据审计和可视化的编程需求非常有用。\nYaml基本语法  大小写敏感 使用缩进表示层级关系  缩进时不允许使用Tab键，只允许使用空格 缩进的空格数量不重要，但是同一层级的元素左侧必须对齐   使用#表示注释  只支持单行注释   一个文件中可以包含多个文件的内容  用---表示内容的开始 用...表示内容的结束（可选）    Yaml数据结构 对象（Mapping） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # key: valueName:enderviggin# 多层嵌套(缩进表示层级关系), 同级中键不能同名Info:Name:endervigginJob:devops# 流式风格Info:{Name: enderviggin, Job:devops}# ?声明一个复杂对象，允许使用多个词汇（数组）来组成键(不常用)? - Name- Job:- enderviggin- devops  数组（Sequence） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 区块格式Names:- ender- viggin- andrew# 内联格式Names:[ender, viggin, andrew]# 多维数组Names:- - ender- viggin- - andrew- enderviggin  字符串（String）   字符串一般不需要使用引号包裹，如果字符串中使用了\\ 开头的转义字符则需要使用引号\n1 2 3 4 5 6 7 8 9  Strings:- ender viggin# 不需要引号包裹- enderviggin# 拆成多行后会自动在中间添加空格- \u0026#39;ender viggin\u0026#39;# 单引号- \u0026#34;ender viggin\u0026#34;# 双引号- \u0026#34;enderviggin. \\u263A\u0026#34;# 使用双引号包裹时支持 Unicode 编码- \u0026#34;\\x0d\\x0a is \\r\\n\u0026#34;# 使用双引号包裹时还支持 Hex 编码- \u0026#39;hello \u0026#34;world!\u0026#34;\u0026#39;# 单双引号支持嵌套\u0026#34;    多行字符串\n  保留换行\n 使用|来表示，每行的默认缩进和行尾空白都会被去掉，而额外的缩进会被保留\n 1 2 3 4 5  Poetry:|人生若只如初见 何事秋风悲画扇 等闲变却故人心 却道故心人易变    折叠换行\n 使用\u0026gt;表示，只有空白行才会被识别为换行吗原来的换行符都会被转换为空格。\n 1 2 3 4 5 6  Poetry:\u0026gt;人生若只如初见 何事秋风悲画扇 等闲变却故人心 却道故心人易变      布尔值（Boolean）   真： true,True,TRUE,yes,Yes, YES\n  假：false,False,FALSE,no,No,NO\n  整数（Integer） 1 2 3  Integer:- 10- 0001_0000# 支持二进制表示  浮点数（Floating） 1 2 3  Float:- 3.14- 6.8523015e+5# 使用科学计数法  空（null） 1 2 3 4 5 6 7  # \u0026#34;null\u0026#34;, \u0026#34;Null\u0026#34;, \u0026#34;~\u0026#34;都是空，不指定默认值也是空Nulls:- null- Null- ~-   时间戳（Timestamp） # yaml也支持ISO 8601格式的时间数据 Date1: 2020-05-26 date2: 2020-05-26T01:00:00+08:00 dete3: 2020-05-26T02:00:00.10+08:00 date4: 2020-05-26 03:00:00.10 +8 类型转换   yaml支持使用严格类型标签!!来强制转换类型\n1 2 3 4 5 6  # !! + 目标类型toFloat:!!float\u0026#39;666\u0026#39;toString:\u0026#39;666\u0026#39;# 引号也算类型转换符Int2String:!!str666# 整数转成字符串Float2String:!!str666.6# 浮点数转字符串Boolean2String !!str true# 布尔值转字符串    数据重用与合并  为了保持内容的简洁，避免过多重复的定义，YAML 提供了由**锚点标签“\u0026amp;”和引用标签“*”**组成的语法，利用这套语法可以快速引用相同的一些数据  1 2 3 4 5 6  Name1:\u0026amp;anchorender:enderviggin:vigginandrew:andrewName2:*anchor   配合**合并标签“\u0026laquo;”**使用可以与任意数据进行合并，你可以把这套操作想象成面向对象语言中的继承  1 2 3 4 5 6 7 8 9 10  Animal:\u0026amp;base# 添加名为base的锚点body:1hair:2Single:\u0026lt;\u0026lt;:*base# 引用 base 锚点，实例化时会自动展开skill:sing# 添加额外的属性Programer:\u0026lt;\u0026lt;:*base# 引用 base 锚点，实例化时会自动展开hair:6# 覆写 base 中的属性skill:code# 添加额外的属性  ","description":"yaml详解","id":2,"section":"posts","tags":["yaml"],"title":"yaml详解","uri":"https://ibora.evcoder.com/posts/yaml%E8%AF%A6%E8%A7%A3/"},{"content":" minikube文档： https://minikube.sigs.k8s.io/docs/\n minikube简介 Minikube 可以实现⼀种轻量级的 Kubernetes 集群，通过在本地计算机上创建虚拟机并部署只包含单个节点的简单集群。\nminikube安装 1.下载minikube osx linux  1  brew install minikube     1 2  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube       'use strict'; var containerId = JSON.parse(\"\\\"52862d538b7a74df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  2.启动minikube 1  minikube start --kubernetes-version=latest --memory=8192mb --cpus=4 --container-runtime=\u0026#39;containerd\u0026#39;   启动参数\n --image-mirror-country=cn: 指定镜像源国家，cn表示中国 --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers: 指定镜像源，这里设置的是阿里云 --kubernetes-version=latest: k8s版本,如果指定latest则安装最新版 --vm-driver=none: 不创建虚拟机 --memory=8192mb: 指定使用多大内存  --cpus=4:指定cpu核心数 --container-runtime='containerd':指定CRI(docker, cri-o, containerd)  查看安装是否成功\n1 2 3  ➜ minikube version minikube version: v1.24.0 commit: 76b94fb3c4e8ac5062daf70d60cf03ddcc0a741b   minikube命令行详解   minikube start 启动集群\n  minikube status 查看集群状态\n1 2 3 4 5 6 7  ➜ minikube status minikube type: Control Plane host: Running kubelet: Running apiserver: Running kubeconfig: Configured     minikube stop 停止集群\n  minikube delete 删除集群\n  更多命令及参数可通过minikube --help或minikube command --help查看\n","description":"minikube安装kubernetes集群","id":3,"section":"posts","tags":["minikube"],"title":"minikube安装kubernetes集群","uri":"https://ibora.evcoder.com/posts/kubernetesminikube%E5%AE%89%E8%A3%85kubernetes%E9%9B%86%E7%BE%A4/"},{"content":"kubectl简介 kubectl是一个用于操作kubernetes集群的命令行工具。\nkubectl安装配置 osx linux  1 2 3 4  brew install kubectl # 或者 curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl sudo mv kubectl /user/bin/kubectl \u0026amp;\u0026amp; chmod +x /usr/bin/kubectl     1 2 3 4 5 6 7 8 9 10 11 12  # 如果需要安装其他版本,用指定版本号替换该命令的这一部分： $(curl -L -s https://dl.k8s.io/release/stable.txt) curl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; # kubectl 校验 curl -LO \u0026#34;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256\u0026#34; echo \u0026#34;$(\u0026lt;kubectl.sha256)kubectl\u0026#34; | sha256sum --check # 安装kubectl sudo mv kubectl /user/bin/kubectl \u0026amp;\u0026amp; chmod +x /usr/bin/kubectl # 自动补全功能 echo \u0026#39;source \u0026lt;(kubectl completion bash)\u0026#39; \u0026gt;\u0026gt;~/.bashrc # kubectl有关联的别名 echo \u0026#39;alias k=kubectl\u0026#39; \u0026gt;\u0026gt;~/.bashrc echo \u0026#39;complete -F __start_kubectl k\u0026#39; \u0026gt;\u0026gt;~/.bashrc       'use strict'; var containerId = JSON.parse(\"\\\"1a8d6a3e213ae051\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kubectl插件 krew 是一个用来管理 kubectl 插件的工具，类似于 apt 或 yum，支持搜索、安装和管理 kubectl 插件。\nkrew安装 1 2 3 4 5 6 7  ( set -x; cd \u0026#34;$(mktemp -d)\u0026#34; \u0026amp;\u0026amp; curl -fsSLO \u0026#34;https://storage.googleapis.com/krew/v0.2.1/krew.{tar.gz,yaml}\u0026#34; \u0026amp;\u0026amp; tar zxvf krew.tar.gz \u0026amp;\u0026amp; ./krew-\u0026#34;$(uname | tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;)_amd64\u0026#34; install \\  --manifest=krew.yaml --archive=krew.tar.gz )   安装完成后，把 krew 的二进制文件加入环境变量 PATH 中：\n1  export PATH=\u0026#34;${KREW_ROOT:-$HOME/.krew}/bin:$PATH\u0026#34;   krew使用 1 2 3 4 5 6 7 8 9 10 11  kubectl krew update # 更新插件索引 kubectl krew search # 展示所有插件 kubectl krew install ssh-jump # 安装插件ssh-jump kubectl ssh-jump # 使用插件 kubectl krew upgrade # 更新已经安装的插件 kubectl krew remove ssh-jump # 卸载插件    在安装插件中，会输出插件所依赖的外部工具，这些工具需要你自己手动安装。\n 创建插件 用任何语言创建的插件，并以前缀 \u0026ldquo;kubectl-\u0026rdquo; 开始为生成的可执行文件命名即可。\n1 2 3 4 5 6 7 8  # kubectl-test sudo chmod a+x kubectl-test sudo mv kubectl-test /usr/local/bin sudo chown root:root /usr/local/bin # 使用 kubectl plugin list kubectl test   kubectl语法 kubectl语法如下：\n1  kubectl [command] [TYPE] [NAME] [flags]   command: command意指你想对某些资源所进行的操作。\nTYPE: 声明command需要操作的资源类型，TYPE对大小写、单数、复数不敏感，支持缩写。\nNAME: 资源的名称，NAME是大小写敏感的。如果不指定某个资源的名称，则显示所有资源（默认的命名空间下）。\nflags： 可选参数。\n 重要：命令行指定的flags将覆盖默认值和任何相应的环境变量。\n 格式化输出 所有 kubectl 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 -o 或 --output 参数添加到受支持的 kubectl 命令中。\n1  kubectl [command] [TYPE] [NAME] -o=\u0026lt;output_format\u0026gt;   根据 kubectl 操作，支持以下输出格式：\n   输出格式 描述     -o custom-columns=\u0026lt;spec\u0026gt; 使用逗号分隔的自定义列列表打印表。   -o custom-columns-file=\u0026lt;filename\u0026gt; 使用 \u0026lt;filename\u0026gt; 文件中的自定义列模板打印表。   -o json 输出 JSON 格式的 API 对象   -o jsonpath=\u0026lt;template\u0026gt; 打印 jsonpath 表达式定义的字段   -o jsonpath-file=\u0026lt;filename\u0026gt; 打印 \u0026lt;filename\u0026gt; 文件中 jsonpath 表达式定义的字段。   -o name 仅打印资源名称而不打印任何其他内容。   -o wide 以纯文本格式输出，包含任何附加信息。   -o yaml 输出 YAML 格式的 API 对象。    自定义列   内联\n1  kubectl get pods \u0026lt;pod-name\u0026gt; -o custom-columns=NAME:.metadata.name,RSRC:.metadata.resourceVersion     模版文件\n1 2 3 4 5  kubectl get pods \u0026lt;pod-name\u0026gt; -o custom-columns-file=template.txt # cat template.txt NAME RSRC metadata.name metadata.resourceVersion     排序列表对象 通过使用 \u0026ndash;sort-by 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用jsonpath表达式。\n1  kubectl [command] [TYPE] [NAME] --sort-by=\u0026lt;jsonpath_exp\u0026gt;   按名称排序的pod列表\n1  kubectl get pods --sort-by=.metadata.name   kubectl命令  kubectl command doc: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands\n 常用操作指南   批量删除\n1 2  # 批量删除状态为Terminating的pod kubectl get pod -A | awk \u0026#39;{if($4==\u0026#34;Terminating\u0026#34;){cmd=\u0026#34;kubectl -n \u0026#34;$1\u0026#34; delete pod \u0026#34;$2; system(cmd)}}\u0026#39;     端口转发\n1 2 3  kubectl port-forward svc/$service_name $local_port:$pod_port --address 0.0.0.0 # 示例 k port-forward service/minio 29001:9001 -n minio --address 0.0.0.0 # 127.0.0.1:29001     平滑移除节点\n1 2 3 4 5 6 7 8 9 10 11 12  # 1.获取需要移除的节点 kubectl get nodes # 2.设置节点为不可调度 ## 由于节点目前处于正常工作状态，集群中新建资源还是有可能创建到该节点的，所以先将节点设置为不可调度 kubectl cordon $node_name # 3.将此节点资源调度到其他节点 ## 目前集群已经不会分配新的资源在该节点上，但是节点还运行着现有的业务，所以需要将节点上的业务分配到其他节点 kubectl drain $node_name # 注意：DaemonSet Pod 和 Static Pod 是不会在集群中其他节点重建的。 # 4.移除节点 ## 集群中已经没有任何资源分配在节点上了，那么我们可以直接移除节点 kubectl delete $node_name     删除不了处于Terminating状态的Pod\n在节点处于“不可用”状态时，CCE会迁移节点上的容器实例，并将节点上运行的pod置为“Terminating”状态。待节点恢复后，处于“Terminating”状态的pod会自动删除。\n偶现部分pod（实例）一直处于“Terminating ”状态\n1 2  # 无论各种方式生成的pod，均可以使用如下命令强制删除 kubectl delete pods \u0026lt;pod\u0026gt; --grace-period=0 --force     删除不了处于Terminating状态的pv,pvc\n1 2 3 4  # 删除pv,pvc步骤：先删pod再删pvc最后删pv。如果遇到pv始终处于“Terminating”状态，而且delete不掉。 ## 直接删除k8s中的记录 kubectl patch pv $pv_name -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;:null}}\u0026#39; kubectl patch pvc $pvc_name -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;:null}}\u0026#39;     node标签操作\n1 2 3 4 5 6  # node添加标签 kubectl label nodes $node_name key=value # node删除标签 kubectl label nodes $node_name key- # 根据标签查询节点 kubectl get node -a -l \u0026#34;key=value\u0026#34;     扩缩容\n1 2  kubectl scale deployment $deployment_name --replicas=$count kubectl scale statefulesets $statefulesets_name --replicas=$count     ","description":"Kubectl 命令行工具管理 Kubernetes 集群","id":4,"section":"posts","tags":["kubectl"],"title":"kubectl命令详解","uri":"https://ibora.evcoder.com/posts/kuberneteskubectl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"kubectl get pod -n enigma2 |grep -E \u0026quot;xfs|kms|accountx|fuwu-api|download|data-service|fuwu-runner|notification|dataset|fednodex|fedapp|workspace|workflow-api|enigma2-dockerunner|project-api\u0026quot;|grep -v \u0026quot;Completed\u0026quot;|awk '{print $1}'|xargs kubectl delete pod -n enigma2 kubectl get pod -n csi-basebit -owide|grep csi|awk '{print $1}'|xargs kubectl delete pod -n csi-basebit ","description":"postgresql系列文章","id":8,"section":"posts","tags":["系列"],"title":"postgresql系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97postgresql%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"mysql简介 MySQL是一个小型的开源的关系型数据库管理系统，MySQL规模小，功能有限，但是它体积小、速度快、成本低，且它提供的功能对稍微复杂的应用已经够用，这些特性使得MySQL成为世界上最受欢迎的开放源代码数据库。\nMySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言——结构化查询语言（SQL）进行数据库管理。\nmysql系列博客列表 ","description":"mysql系列文章","id":11,"section":"posts","tags":["系列"],"title":"mysql系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97mysql%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"traefik简介 Traefik 是一款 边缘路由器，可让您轻松地发布服务. 它接收来自您的系统请求，并找出负责处理它们的后端服务组件。\ntraefik 与众不同在于它能够自动发现适合您服务的配置。 当 Traefik 检查您的基础设施时，它会发现相关信息，并发现哪个服务服务于哪个请求。\nTraefik 支持多种集群技术，如 Kubernetes，Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon; 并且可以同时处理多个 providers。\n使用 Traefik，无需维护和同步配置文件：所有操作都会自动实时完成（无重启，不用中断服务）。 使用 Traefik，您只需花时间于系统开发和部署新功能，而不是配置和维护其工作状态。\ntraefik系列博客列表 ","description":"traefik系列文章","id":22,"section":"posts","tags":["系列"],"title":"traefik系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97traefik%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"golang简介 go语言（或 Golang）是Google开发的开源编程语言，诞生于2006年1月2日，于2009年11月开源，2012年发布go稳定版。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。\ngolang系列博客列表  golang语法 golang标准库 golang三方库 golang爬虫 golang web框架 golang微服务框架  ","description":"golang系列文章","id":32,"section":"posts","tags":["系列"],"title":"golang系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97golang%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"prometheus简介 ","description":"prometheus系列文章","id":35,"section":"posts","tags":["系列"],"title":"prometheus系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97prometheus%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"kubernetes简介 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。该项目托管在CNCF。\nKubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。是 Google 多年大规模容器管理技术 Borg 的开源版本，结合了社区中最好的想法和实践。\nkubernetes功能：\n  服务发现和负载均衡\nKubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。\n  存储编排\nKubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。\n  自动部署和回滚\n你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。\n  自动完成装箱计算\nKubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。\n  自我修复\nKubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。\n  密钥与配置管理\nKubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。\n  kubernetes系列博客列表   kubernetes部署\n minikube安装kubernetes集群 kind安装kubernetes集群 kubeadm安装kubernetes集群 kubespray安装kubernetes集群 sealos安装kubernetes集群    kubernetes管理工具\n rancher  rancher部署文档   kubesphere    kubernetes架构\n  kubernetes核心组件\n etcd kube-apiserver kube-scheduler kube-controller-manager kubelet kube-proxy    kubernetes附加组件\n CoreDns    kubernetes网络插件\n CNI flannel calico    kubernetes资源对象\n kubernetes CustomResourceDefinition详解 kubernetes ConfigMap详解 kubernetes CronJob详解 kubernetes DaemonSet详解 kubernetes Deployment详解 kubernetes Ingress详解 kubernetes Job详解 kubernetes LocalValume详解 kubernetes Namespace详解 kubernetes NetworkPolicy详解 kubernetes Node详解 kubernetes PersistentVolume详解 kubernetes Pod详解 kubernetes PodPreset详解 kubernetes RelicaSet详解 kubernetes Quota详解 kubernetes Secret详解 kubernetes SecurityContext详解 kubernetes Service详解 kubernetes ServiceAccount详解 kubernetes StatefulSet详解 kubernetes Volume详解    kubernetes命令行工具\n kubectl命令详解 kubectx命令详解 kubens命令详解 kubecm命令详解    ","description":"kubernetes系列文章","id":38,"section":"posts","tags":["系列"],"title":"kubernetes系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97kubernetes%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"openstack简介  openstack官网: https://www.openstack.org/\nopenstack gitHub: https://github.com/openstack\n OpenStack是一个云操作系统，通过数据中心可控制大型的计算、存储、网络等资源池。所有的管理通过前端界面管理员就可以完成，同样也可以通过web接口让最终用户部署资源。\nOpenStack系统由几个关键服务组成，它们可以单独安装。这些服务根据你的云需求工作在一起。这些服务包括计算服务、认证服务、网络服务、镜像服务、块存储服务、对象存储服务、计量服务、编排服务和数据库服务。您可以独立安装这些服务、独自配置它们或者连接成一个整体。\nopenstack组件    服务 组件名称 描述     dashboard horizon 提供了一个基于web的自服务门户，与OpenStack底层服务交互，诸如启动一个实例，分配IP地址以及配置访问控制。   计算 nova 在OpenStack环境中计算实例的生命周期管理。按需响应包括生成、调度、回收虚拟机等操作。   网络 neutron 确保为其它OpenStack服务提供网络连接即服务，比如OpenStack计算。为用户提供API定义网络和使用。基于插件的架构其支持众多的网络提供商和技术。   对象存储 swift 通过一个 RESTful,基于HTTP的应用程序接口存储和任意检索的非结构化数据对象。它拥有高容错机制，基于数据复制和可扩展架构。它的实现并像是一个文件服务器需要挂载目录。在此种方式下，它写入对象和文件到多个硬盘中，以确保数据是在集群内跨服务器的多份复制。   块存储 cinder 为运行实例而提供的持久性块存储。它的可插拔驱动架构的功能有助于创建和管理块存储设备。   身份服务 keystone 为其他OpenStack服务提供认证和授权服务，为所有的OpenStack服务提供一个端点目录。   镜像服务 glance 存储和检索虚拟机磁盘镜像，OpenStack计算会在实例部署时使用此服务。   遥测服务 Ceilometer 为OpenStack云的计费、基准、扩展性以及统计等目的提供监测和计量。   编排服务 Heat 既可以使用本地模板格式，亦可使用AWS CloudFormation模板格式，来编排多个综合的云应用，通过OpenStack本地REST API或者是CloudFormation相兼容的队列API。    openstack系列博客列表  openstack部署  Openstack部署文档 kolla部署openstack文档   openstack组件  horizon组件详解 nova组件详解 neutron组件详解 swift组件详解 cinder组件详解 keystone组件详解 glance组件详解 ceilometer组件详解 heat组件详解   openstack仪表盘 openstack命令行客户端  openstack命令行客户端安装 openstack命令行管理镜像 openstack命令行管理卷 openstack命令行管理共享 openstack命令行设定实例的权限和安全设置 openstack命令行启动云主机 openstack命令行管理实例和主机 openstack命令行为实例提供用户数据 openstack命令行使用快照来迁移实例 openstack命令行在配置驱动上存储元数据 openstack命令行创建和管理网路 openstack命令行创建和管理栈   openstack python SDK  ","description":"openstack系列文章","id":39,"section":"posts","tags":["openstack"],"title":"openstack系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97openstack%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":" kolla文档地址： https://docs.openstack.org/kolla-ansible/xena/index.html\nkolla github地址： https://github.com/openstack/kolla\n 1. all-in-one模式 2. Multinode模式 主机配置规划    主机名 网口（nat/bridge） cpu 内存 磁盘 系统     kolla-controller 10.0.0.10/ 4c 8G 40G ubuntu20.04   kolla-compute01 10.0.0.11/ 4c 8G 30G ubuntu20.04   kolla-compute02 10.0.0.12/ 4c 8G 30G ubuntu20.04   kolla-compute03 10.0.0.13/ 4c 8G 30G ubuntu20.04   kolla-storage 10.0.0.14/ 2c 4G 500G ubuntu20.04    初始化环境配置 1.替换镜像源 1 2 3 4 5 6 7 8  # 首先备份源列表--ubuntu20.04 sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup vim /etc/apt/sources.list # 添加ubuntu20.04的配置 https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b1176Cuex sudo apt upate sudo apt upgrade   2.安装依赖包 1  apt-get install python-dev libffi-dev gcc libssl-dev python-selinux python-setuptools git vim -y   3.安装ansible 1 2 3 4 5 6 7 8  sudo apt install ansible # 配置ansible vim /etc/ansible/ansible.cfg [defaults] host_key_checking=False pipelining=True forks=100   4.安装kolla-ansible 1 2 3 4 5 6 7 8 9  # 下载安装包 git clone --branch stable/xena https://opendev.org/openstack/kolla-ansible sudo pip3 install ./kolla-ansible # 创建kolla配置文件目录 sudo mkdir -p /etc/kolla sudo chown $USER:$USER /etc/kolla cp -r kolla-ansible/etc/kolla/* /etc/kolla cp kolla-ansible/ansible/inventory/* .   5.修改配置文件 6.检查库文件配置是否正确 ansible -i multinode all -m ping 7.生成密码 1 2  cd kolla-ansible/tools ./generate_passwords.py   ","description":"kolla部署openstack","id":40,"section":"posts","tags":["openstack"],"title":"kolla部署openstack文档","uri":"https://ibora.evcoder.com/posts/openstackkolla%E9%83%A8%E7%BD%B2openstack%E6%96%87%E6%A1%A3/"},{"content":"环境准备 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;hello world!!!!\u0026#34;) }   初始化 ","description":"openstack 部署手册","id":41,"section":"posts","tags":["openstack"],"title":"Openstack部署文档","uri":"https://ibora.evcoder.com/posts/openstackopenstack%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"},{"content":"图册收集\n","description":"photo gallery","id":43,"section":"","tags":null,"title":"图册","uri":"https://ibora.evcoder.com/gallery/"}]