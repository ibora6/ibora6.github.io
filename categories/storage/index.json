[{"content":"Terraform的配置语言为HCL（HashiCorp Configuration Language），它是HashiCorp发明的一种声明式语言，能够以更加简短和人性化的方式来描述资源。\n","description":"terraform语法详解","id":2,"section":"posts","tags":["系列"],"title":"terraform语法详解","uri":"https://ibora.evcoder.com/posts/terraformterraform%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3/"},{"content":"Configuration：基础设施的定义和描述 “基础设施即代码（Infrastructure as Code）”，这里的Code就是对基础设施资源的代码定义和描述，也就是通过代码表达我们想要管理的资源。\n对所有资源的代码描述都需要定义在一个以 tf 结尾的文件用于Terraform加载和解析，这个文件我们称之为“Terraform模板”或者“Configuration”。\nProvider：基础设施管理组件 Provider是一个与Open API直接交互的后端驱动，Terraform 就是通过Provider来完成对基础设施资源的管理的。不同的基础设施提供商都需要提供一个Provider来实现对自家基础设施的统一管理。目前Terraform目前支持超过160多种的providers，大多数云平台的Provider插件均已经实现\n在操作环境中，Terraform和Provider是两个独立存在的package，当运行Terraform时，Terraform会根据用户模板中指定的provider或者resource／datasource的标志自动的下载模板所用到的所有provider，并将其放在执行目录下的一个隐藏目录 .terraform 下。\nResource：基础设施资源和服务的管理 在Terraform中，一个具体的资源或者服务称之为一个resource。每个特定的resource包含了若干可用于描述对应资源或者服务的属性字段，通过这些字段来定义一个完整的资源或者服务。\nData Source：基础设施资源和服务的查询 在Terraform 中，Data Source 提供的就是一个查询资源的功能，每个data source实现对一个资源的动态查询，Data Souce的结果可以认为是动态变量，只有在运行时才能知道变量的值。\nState：保存资源关系及其属性文件的数据库 Terraform创建和管理的所有资源都会保存到自己的数据库上，这个数据库不是通常意义上的数据库，而是一个文件名为 terraform.tfstate 的文件，在Terraform 中称之为 state，默认存放在执行Terraform命令的本地目录下。这个 state 文件非常重要，如果该文件损坏，Terraform 将认为已创建的资源被破坏或者需要重建（实际的云资源通常不会受到影响），因为在执行Terraform命令时，Terraform将会利用该文件与当前目录下的模板做Diff比较，如果出现不一致，Terraform将按照模板中的定义重新创建或者修改已有资源，直到没有Diff，因此可以认为Terraform是一个有状态服务。\n当涉及多人协作时不仅需要拷贝模板，还需要拷贝 state 文件，这无形中增加了维护成本。幸运的是，目前Terraform支持把 state 文件放到远端的存储服务 OSS 上或者 consul 上，来实现 state 文件和模板代码的分离。\nBackend：存放 State 文件的载体 Terraform 在创建完资源后，会将资源的属性存放在一个 state 文件中。\n local：本地存储\n即资源状态存放在本地的一个state文件中，默认为执行目录下的名为 terraform.tfstate 文件。此方式也是Terraform默认的存储形式。 remote：远端存储\n即资源状态存放在远端的一个服务中。远端存储带来的好处是实现了与资源定义模板管理的解耦，可以让State脱离本地磁盘而存储，在提升State安全性的同时，团队协作可以不再受制于Terraform的执行环境，执行目录和多人执行时间的限制，提升了管理的灵活性。  Terraform State的存储是由一个称之为 Backend 的组件决定的，local state使用的是local backend。除了local backend，其他所有的backend在使用之前都需要在模板中显示定义并通过 terraform init 来实现加载和配置。\nBackend 是存储State的机制，它决定了State数据的加载逻辑和Terraform命令执行之后State的数据的更新过程。\nProvisioner：在机器上执行操作的组件 Provisioner通常用来在本地机器或者登陆远程主机执行相关的操作，如 local-exec provisioner 用来执行本地的命令， chef provisioner 用来在远程机器安装，配置和执行chef client， remote-exec provisioner 用来登录远程主机并在其上执行命令。\nProvisioner 通常跟 Provider一起配合使用，provider用来创建和管理资源，provisioner在创建好的机器上执行各种操作。\n","description":"terraform概念详解","id":3,"section":"posts","tags":["系列"],"title":"terraform概念详解","uri":"https://ibora.evcoder.com/posts/terraformterraform%E6%A6%82%E5%BF%B5%E8%AF%A6%E8%A7%A3/"},{"content":"资源管理常用命令 Terraform 对资源的管理主要是对资源生命周期的管理，即通过命令实现对Terraform模板中所定义资源的创建，修改，查看和删除。\nterraform plan: 资源预览 plan 命令用于对模板中所定义资源的预览，主要用于以下几个场景：\n 预览当前模板中定义的资源是否符合管理预期 如果当前模板已经存在对应的state文件，那么 plan 命令将会展示模板定义与state文件内容的diff结果，如果有变更，将会展示结果并在下方显示出来 对DataSource而言，执行 plan 命令，即可直接获取并输出所要查询的资源及其属性  1  terraform plan   terraform apply：资源新建和变更 apply 命令用于实际资源的新建和变更操作，为了安全起见，在命令运行过程中增加了人工交互的过程，即需要手动确认是否继续，当然也可以通过 --auto-approve 参数来跳过人工确认的过程。\napply 命令适用于以下几种场景：\n 创建新的资源 通过修改模板参数来修改资源的属性 如果从当前模板中删除某个资源的定义， apply 命令会将该资源彻底删除。可以理解为“资源的移除也是一种变更”  terraform show：资源的展示 show 命令用于展示当前state中所有被管理的资源及其所有属性值。\nterraform destroy：资源释放 destroy 命令用于对资源的释放操作，为了安全起见，在命令执行过程中，也增加了人工交互的过程，如果想要跳过手动确认操作，可以通过 --force 参数来跳过。\nterraform destroy 默认会释放当前模板中定义的所有资源，如果只想释放其中某个特定的资源，可以通过参数 -target=\u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt; 来指定。\n1.5 terraform import：资源导入 import 命令用于将存量的云资源导入到terraform state中，进而加入到Terraform的管理体系中，适用的场景包含但不限于以下几种：\n 从来没有使用Terraform管控过任何资源，当前所有的存量云资源都是通过控制台，CLI，ROS或者直接调用API创建和管理的，现在想要切换为Terraform管理 在不影响资源正常使用的前提下，重构资源模板中的资源定义  terraform taint: 标记资源为“被污染” taint 命令用于把某个资源标记为“被污染”状态，当再次执行 apply 命令时，这个被污染的资源将会被先释放，然后再创建一个新的，相当于对这个特定资源做了先删除后新建的操作。\n命令的详细格式为： terraform taint \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt;\nterraform untaint：取消“被污染”标记 untaint 命令是 taint 的逆向操作，用于取消“被污染”标记，使其恢复到正常的状态。命令的详细格式和 taint 类似为： terraform untaint \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt;\nterraform output：打印出参及其值 如果在模板中显示定义了 output 参数，那么这个output的值将在 apply 命令之后展示，但 plan 命令并不会展示，如果想随时随地快速查看output的值，可以直接运行命令 terraform output\n状态管理常用命令 Terraform 对资源状态的管理，实际上是对State文件中数据的管理。State文件保存了当前Terraform管理的所有资源及其属性，内容都是由Terraform自动存储的，为了保证数据的完整性，不建议手动修改State内容。\n对State数据的操作可以通过 terraform state 命令来完成。\nterraform state list：列出当前state中的所有资源 state list 按照 \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt; 的格式列出当前state中存在的所有资源（包括datasource）\nterraform state show：展示某一个资源的属性 state show 命令按照Key-Value的格式展示出特定资源的所有属性及其值，命令的完整格式为 terraform state show \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt;\nterraform state pull：获取当前state内容并展示 state pull 命令用于原样展示当前state文件数据，类似与Shell下的cat命令\nterraform state rm：移除特定的资源 state rm 命令用于将state中的某个资源移除，但是实际上并不会真正删除这个资源，命令格式为： terraform state rm \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称\u0026gt;\n移除后，如果模板内容不变并且再次执行 apply 命令，将会新增一个同样的资源。移除后的资源可以再次通过 import 命令再次加入\nterraform state mv：变更特定资源的存放地址 如果想调整某个资源所在的state文件，可以通过 state mv 命令来完成，类似于Shell下的mv命令，这个命令的使用有多种选项，可以通过命令 terraform state mv --help 来详细了解。本文只介绍最常用的一种： terraform state mv --state=./terraform.tfstate --state-out=\u0026lt;target path\u0026gt;/terraform-target.tfstate \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称A\u0026gt; \u0026lt;资源类型\u0026gt;.\u0026lt;资源名称B\u0026gt;\nterraform refresh：刷新当前state refresh 命令可以用来刷新当前State的内容，即再次调用API并拉取最新的数据写入到state文件中。\n其他常用命令 除了资源和state的管理命令外，还有一些常用的应用在模板，provider等多种场景下的命令。\nterraform init：初始化加载模块 init 用来初始化加载所需的模块，包括Provider，Provisioner，Module等。\nterraform graph：输出当前模板定义的资源关系图 每个模板定义的资源之间都存在不同程度的关系，如果想看资源关系大图，可以使用命令 terraform graph\n该命令的结果还可以通过命令 terraform graph | dot -Tsvg \u0026gt; graph.svg 直接导出为一张图片（需要提前安装graphviz： brew install graphviz ）：\nterraform validate：验证模板语法是否正确 Terraform 模板的编写需要遵循其自身定义的一套简单的语法规范，编写完成后，如果想要检查模板是否存在语法错误或者在运行 plan 和 apply 命令的时候报语法错误，可以通过执行命令 terraform validate 来检查和定位错误出现的详细位置和原因。\n","description":"terraform命令行详解","id":4,"section":"posts","tags":["系列"],"title":"terraform命令行详解","uri":"https://ibora.evcoder.com/posts/terraformterraform%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%AF%A6%E8%A7%A3/"},{"content":"架构 Kubernetes 遵循非常传统的客户端服务端架构，客户端通过 RESTful 接口或者直接使用 kubectl 与Kubernetes 集群进行通信。每一个 Kubernetes 集群都由一组 Master 节点和一系列的Node节点组成，其中 Master 节点主要负责存储集群的状态并为 Kubernetes 对象分配和调度资源。\nMaster服务端也被称为主控节点。\n 主要任务：  负责管理所有节点。 负责调度Pod到哪些节点上运行。 负责控制集群运行过程中的所有状态。   主要组件  kube-apiserver组件：集群的HTTP REST API接口，是集群控制的入口。 kube-controller-manager组件：集群中所有资源对象的自动化控制中心。 kube-scheduler组件：集群中Pod资源对象的调度服务。    Node客户端也被称为工作节点。\n 主要任务  负责管理所有容器。 负责监控/上报所有Pod的运行状态。   主要组件  kubelet组件：负责管理节点上容器的创建、删除、启停等任务，与Master节点进行通信。 kube-proxy组件：负责Kubernetes服务的通信及负载均衡服务。 container组件：负责容器的基础管理服务，接收kubelet组件的指令。    组件简述 kubectl kubectl是Kubernetes官方提供的命令行工具，用户可以通过kubectl以命令行交互的方式对Kubernetes API Server进行操作，通信协议使用HTTP/JSON。\nkubectl发送相应的HTTP请求，请求由Kubernetes API Server接收、处理并将结果反馈给kubectl。kubectl接收到响应并展示结果。至此，kubectl与kube-apiserver的一次请求周期结束。\nkube-apiserver kube-apiserver组件，也被称为Kubernetes API Server。它负责将Kubernetes“资源组/资源版本/资源”以RESTful风格的形式对外暴露并提供服务。Kubernetes集群中的所有组件都通过kube-apiserver组件操作资源对象。kube-apiserver组件也是集群中唯一与etcd集群进行交互的核心组件。\netcd集群是分布式键值存储集群，其提供了可靠的强一致性服务发现。etcd集群存储Kubernetes系统集群的状态和元数据，其中包括所有Kubernetes资源对象信息、集群节点信息等。Kubernetes将所有数据存储至etcd集群中前缀为/registry的目录下。\nkube-apiserver属于核心组件，具有以下重要特性：\n 将Kubernetes系统中的所有资源对象都封装成RESTful风格的API接口进行管理。 可进行集群状态管理和数据管理，是唯一与Etcd集群交互的组件。 拥有丰富的集群安全访问机制，以及认证、授权及准入控制器。 提供了集群各组件的通信和交互功能。  kube-controller-manager kube-controller-manager组件，也被称为Controller Manager（管理控制器），它负责管理Kubernetes集群中的节点、Pod副本、服务、端点、命名空间、服务账户、资源定额等。\nController Manager负责确保Kubernetes系统的实际状态收敛到所需状态，其默认提供了一些控制器，每个控制器通过kube-apiserver组件提供的接口实时监控整个集群每个资源对象的当前状态，当因发生各种故障而导致系统状态出现变化时，会尝试将系统状态修复到“期望状态”。\nController Manager具备高可用性，即基于Etcd集群上的分布式锁实现领导者选举机制，多实例同时运行，通过kube-apiserver提供的资源锁进行选举竞争。抢先获取锁的实例被称为Leader节点，并运行kube-controller-manager组件的主逻辑；而未获取锁的实例被称为Candidate节点，运行时处于阻塞状态。在Leader节点因某些原因退出后，Candidate节点则通过领导者选举机制参与竞选，成为Leader节点后接替kube-controller-manager的工作。\nkube-scheduler kube-scheduler组件，也被称为调度器，目前是Kubernetes集群的默认调度器。它负责在Kubernetes集群中为一个Pod资源对象找到合适的节点并在该节点上运行。调度器每次只调度一个Pod资源对象，为每一个Pod资源对象寻找合适节点的过程是一个调度周期。\nkube-scheduler组件监控整个集群的Pod资源对象和Node资源对象，当监控到新的Pod资源对象时，会通过调度算法为其选择最优节点。调度算法分为两种，分别为预选调度算法和优选调度算法。除调度策略外，Kubernetes还支持优先级调度、抢占机制及亲和性调度等功能。\nkube-scheduler组件支持高可用性，即基于Etcd集群上的分布式锁实现领导者选举机制，多实例同时运行，通过kube-apiserver提供的资源锁进行选举竞争。抢先获取锁的实例被称为Leader节点，并运行kube-scheduler组件的主逻辑；而未获取锁的实例被称为Candidate节点，运行时处于阻塞状态。在Leader节点因某些原因退出后，Candidate节点则通过领导者选举机制参与竞选，成为Leader节点后接替kube-scheduler的工作。\nkubelet kubelet组件，用于管理节点，运行在每个Kubernetes节点上。kubelet组件用来接收、处理、上报kube-apiserver组件下发的任务。kubelet进程启动时会向kube-apiserver注册节点自身信息。它主要负责所在节点上的Pod资源对象的管理，例如Pod资源对象的创建、修改、监控、删除、驱逐及Pod生命周期管理等。\nkubelet组件会定期监控所在节点的资源使用状态并上报给kube-apiserver组件，这些资源数据可以帮助kube-scheduler调度器为Pod资源对象预选节点。kubelet也会对所在节点的镜像和容器做清理工作，保证节点上的镜像不会占满磁盘空间、删除的容器释放相关资源。\nkubelet组件实现了3种开放接口：\n Container Runtime Interface(容器运行时接口) Container Network Interface(容器网络接口) Container Storage Interface(容器存储接口)  Container Runtime Interface：简称CRI（容器运行时接口），提供容器运行时通用插件接口服务。CRI定义了容器和镜像服务的接口。CRI将kubelet组件与容器运行时进行解耦，将原来完全面向Pod级别的内部接口拆分成面向Sandbox和Container的gRPC接口，并将镜像管理和容器管理分离给不同的服务。\nContainer Network Interface：简称CNI（容器网络接口），提供网络通用插件接口服务。CNI定义了Kubernetes网络插件的基础，容器创建时通过CNI插件配置网络。\nContainer Storage Interface：简称CSI（容器存储接口），提供存储通用插件接口服务。CSI定义了容器存储卷标准规范，容器创建时通过CSI插件配置存储卷。\nkube-proxy kube-proxy组件，作为节点上的网络代理，运行在每个Kubernetes节点上。它监控kube-apiserver的服务和端点资源变化，并通过iptables/ipvs等配置负载均衡器，为一组Pod提供统一的TCP/UDP流量转发和负载均衡功能。\nkube-proxy组件是参与管理Pod-to-Service和External-to-Service网络的最重要的节点组件之一。kube-proxy组件相当于代理模型，对于某个IP:Port的请求，负责将其转发给专用网络上的相应服务或应用程序。但是，kube-proxy组件与其他负载均衡服务的区别在于，kube-proxy代理只向Kubernetes服务及其后端Pod发出请求。\n","description":"kubernetes架构","id":5,"section":"posts","tags":["kubernetes"],"title":"kubernetes架构","uri":"https://ibora.evcoder.com/posts/kuberneteskubernetes%E6%9E%B6%E6%9E%84/"},{"content":" ","description":"github Package详解","id":6,"section":"posts","tags":["GitHub"],"title":"github Package详解","uri":"https://ibora.evcoder.com/posts/gitgithub-package%E8%AF%A6%E8%A7%A3/"},{"content":"Yaml简介 YAML是一种人性化、跨语言、基于 Unicode 的数据序列化语言，它围绕动态编程语言的常见本机数据类型而设计。它对于从配置文件到 Internet 消息传递到对象持久性再到数据审计和可视化的编程需求非常有用。\nYaml基本语法  大小写敏感 使用缩进表示层级关系  缩进时不允许使用Tab键，只允许使用空格 缩进的空格数量不重要，但是同一层级的元素左侧必须对齐   使用#表示注释  只支持单行注释   一个文件中可以包含多个文件的内容  用---表示内容的开始 用...表示内容的结束（可选）    Yaml数据结构 对象（Mapping） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # key: valueName:enderviggin# 多层嵌套(缩进表示层级关系), 同级中键不能同名Info:Name:endervigginJob:devops# 流式风格Info:{Name: enderviggin, Job:devops}# ?声明一个复杂对象，允许使用多个词汇（数组）来组成键(不常用)? - Name- Job:- enderviggin- devops  数组（Sequence） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  # 区块格式Names:- ender- viggin- andrew# 内联格式Names:[ender, viggin, andrew]# 多维数组Names:- - ender- viggin- - andrew- enderviggin  字符串（String）   字符串一般不需要使用引号包裹，如果字符串中使用了\\ 开头的转义字符则需要使用引号\n1 2 3 4 5 6 7 8 9  Strings:- ender viggin# 不需要引号包裹- enderviggin# 拆成多行后会自动在中间添加空格- \u0026#39;ender viggin\u0026#39;# 单引号- \u0026#34;ender viggin\u0026#34;# 双引号- \u0026#34;enderviggin. \\u263A\u0026#34;# 使用双引号包裹时支持 Unicode 编码- \u0026#34;\\x0d\\x0a is \\r\\n\u0026#34;# 使用双引号包裹时还支持 Hex 编码- \u0026#39;hello \u0026#34;world!\u0026#34;\u0026#39;# 单双引号支持嵌套\u0026#34;    多行字符串\n  保留换行\n 使用|来表示，每行的默认缩进和行尾空白都会被去掉，而额外的缩进会被保留\n 1 2 3 4 5  Poetry:|人生若只如初见 何事秋风悲画扇 等闲变却故人心 却道故心人易变    折叠换行\n 使用\u0026gt;表示，只有空白行才会被识别为换行吗原来的换行符都会被转换为空格。\n 1 2 3 4 5 6  Poetry:\u0026gt;人生若只如初见 何事秋风悲画扇 等闲变却故人心 却道故心人易变      布尔值（Boolean）   真： true,True,TRUE,yes,Yes, YES\n  假：false,False,FALSE,no,No,NO\n  整数（Integer） 1 2 3  Integer:- 10- 0001_0000# 支持二进制表示  浮点数（Floating） 1 2 3  Float:- 3.14- 6.8523015e+5# 使用科学计数法  空（null） 1 2 3 4 5 6 7  # \u0026#34;null\u0026#34;, \u0026#34;Null\u0026#34;, \u0026#34;~\u0026#34;都是空，不指定默认值也是空Nulls:- null- Null- ~-   时间戳（Timestamp） # yaml也支持ISO 8601格式的时间数据 Date1: 2020-05-26 date2: 2020-05-26T01:00:00+08:00 dete3: 2020-05-26T02:00:00.10+08:00 date4: 2020-05-26 03:00:00.10 +8 类型转换   yaml支持使用严格类型标签!!来强制转换类型\n1 2 3 4 5 6  # !! + 目标类型toFloat:!!float\u0026#39;666\u0026#39;toString:\u0026#39;666\u0026#39;# 引号也算类型转换符Int2String:!!str666# 整数转成字符串Float2String:!!str666.6# 浮点数转字符串Boolean2String !!str true# 布尔值转字符串    数据重用与合并  为了保持内容的简洁，避免过多重复的定义，YAML 提供了由**锚点标签“\u0026amp;”和引用标签“*”**组成的语法，利用这套语法可以快速引用相同的一些数据  1 2 3 4 5 6  Name1:\u0026amp;anchorender:enderviggin:vigginandrew:andrewName2:*anchor   配合**合并标签“\u0026laquo;”**使用可以与任意数据进行合并，你可以把这套操作想象成面向对象语言中的继承  1 2 3 4 5 6 7 8 9 10  Animal:\u0026amp;base# 添加名为base的锚点body:1hair:2Single:\u0026lt;\u0026lt;:*base# 引用 base 锚点，实例化时会自动展开skill:sing# 添加额外的属性Programer:\u0026lt;\u0026lt;:*base# 引用 base 锚点，实例化时会自动展开hair:6# 覆写 base 中的属性skill:code# 添加额外的属性  ","description":"yaml详解","id":7,"section":"posts","tags":["yaml"],"title":"yaml详解","uri":"https://ibora.evcoder.com/posts/yaml%E8%AF%A6%E8%A7%A3/"},{"content":" minikube文档： https://minikube.sigs.k8s.io/docs/\n minikube简介 Minikube 可以实现⼀种轻量级的 Kubernetes 集群，通过在本地计算机上创建虚拟机并部署只包含单个节点的简单集群。\nminikube安装 1.下载minikube osx linux  1  brew install minikube     1 2  curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube       'use strict'; var containerId = JSON.parse(\"\\\"52862d538b7a74df\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  2.启动minikube 1  minikube start --kubernetes-version=latest --memory=8192mb --cpus=4 --container-runtime=\u0026#39;containerd\u0026#39;   启动参数\n --image-mirror-country=cn: 指定镜像源国家，cn表示中国 --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers: 指定镜像源，这里设置的是阿里云 --kubernetes-version=latest: k8s版本,如果指定latest则安装最新版 --vm-driver=none: 不创建虚拟机 --memory=8192mb: 指定使用多大内存  --cpus=4:指定cpu核心数 --container-runtime='containerd':指定CRI(docker, cri-o, containerd)  查看安装是否成功\n1 2 3  ➜ minikube version minikube version: v1.24.0 commit: 76b94fb3c4e8ac5062daf70d60cf03ddcc0a741b   minikube命令行详解   minikube start 启动集群\n  minikube status 查看集群状态\n1 2 3 4 5 6 7  ➜ minikube status minikube type: Control Plane host: Running kubelet: Running apiserver: Running kubeconfig: Configured     minikube stop 停止集群\n  minikube delete 删除集群\n  更多命令及参数可通过minikube --help或minikube command --help查看\n","description":"minikube安装kubernetes集群","id":8,"section":"posts","tags":["minikube"],"title":"minikube安装kubernetes集群","uri":"https://ibora.evcoder.com/posts/kubernetesminikube%E5%AE%89%E8%A3%85kubernetes%E9%9B%86%E7%BE%A4/"},{"content":"kubectl简介 kubectl是一个用于操作kubernetes集群的命令行工具。\nkubectl安装配置 osx linux  1 2 3 4  brew install kubectl # 或者 curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl sudo mv kubectl /user/bin/kubectl \u0026amp;\u0026amp; chmod +x /usr/bin/kubectl     1 2 3 4 5 6 7 8 9 10 11 12  # 如果需要安装其他版本,用指定版本号替换该命令的这一部分： $(curl -L -s https://dl.k8s.io/release/stable.txt) curl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; # kubectl 校验 curl -LO \u0026#34;https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256\u0026#34; echo \u0026#34;$(\u0026lt;kubectl.sha256)kubectl\u0026#34; | sha256sum --check # 安装kubectl sudo mv kubectl /user/bin/kubectl \u0026amp;\u0026amp; chmod +x /usr/bin/kubectl # 自动补全功能 echo \u0026#39;source \u0026lt;(kubectl completion bash)\u0026#39; \u0026gt;\u0026gt;~/.bashrc # kubectl有关联的别名 echo \u0026#39;alias k=kubectl\u0026#39; \u0026gt;\u0026gt;~/.bashrc echo \u0026#39;complete -F __start_kubectl k\u0026#39; \u0026gt;\u0026gt;~/.bashrc       'use strict'; var containerId = JSON.parse(\"\\\"1a8d6a3e213ae051\\\"\"); var containerElem = document.getElementById(containerId); var codetabLinks = null; var codetabContents = null; var ids = []; if (containerElem) { codetabLinks = containerElem.querySelectorAll('.codetab__link'); codetabContents = containerElem.querySelectorAll('.codetab__content'); } for (var i = 0; i 0) { codetabContents[0].style.display = 'block'; }  kubectl插件 krew 是一个用来管理 kubectl 插件的工具，类似于 apt 或 yum，支持搜索、安装和管理 kubectl 插件。\nkrew安装 1 2 3 4 5 6 7  ( set -x; cd \u0026#34;$(mktemp -d)\u0026#34; \u0026amp;\u0026amp; curl -fsSLO \u0026#34;https://storage.googleapis.com/krew/v0.2.1/krew.{tar.gz,yaml}\u0026#34; \u0026amp;\u0026amp; tar zxvf krew.tar.gz \u0026amp;\u0026amp; ./krew-\u0026#34;$(uname | tr \u0026#39;[:upper:]\u0026#39; \u0026#39;[:lower:]\u0026#39;)_amd64\u0026#34; install \\  --manifest=krew.yaml --archive=krew.tar.gz )   安装完成后，把 krew 的二进制文件加入环境变量 PATH 中：\n1  export PATH=\u0026#34;${KREW_ROOT:-$HOME/.krew}/bin:$PATH\u0026#34;   krew使用 1 2 3 4 5 6 7 8 9 10 11  kubectl krew update # 更新插件索引 kubectl krew search # 展示所有插件 kubectl krew install ssh-jump # 安装插件ssh-jump kubectl ssh-jump # 使用插件 kubectl krew upgrade # 更新已经安装的插件 kubectl krew remove ssh-jump # 卸载插件    在安装插件中，会输出插件所依赖的外部工具，这些工具需要你自己手动安装。\n 创建插件 用任何语言创建的插件，并以前缀 \u0026ldquo;kubectl-\u0026rdquo; 开始为生成的可执行文件命名即可。\n1 2 3 4 5 6 7 8  # kubectl-test sudo chmod a+x kubectl-test sudo mv kubectl-test /usr/local/bin sudo chown root:root /usr/local/bin # 使用 kubectl plugin list kubectl test   kubectl语法 kubectl语法如下：\n1  kubectl [command] [TYPE] [NAME] [flags]   command: command意指你想对某些资源所进行的操作。\nTYPE: 声明command需要操作的资源类型，TYPE对大小写、单数、复数不敏感，支持缩写。\nNAME: 资源的名称，NAME是大小写敏感的。如果不指定某个资源的名称，则显示所有资源（默认的命名空间下）。\nflags： 可选参数。\n 重要：命令行指定的flags将覆盖默认值和任何相应的环境变量。\n 格式化输出 所有 kubectl 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式向终端窗口输出详细信息，可以将 -o 或 --output 参数添加到受支持的 kubectl 命令中。\n1  kubectl [command] [TYPE] [NAME] -o=\u0026lt;output_format\u0026gt;   根据 kubectl 操作，支持以下输出格式：\n   输出格式 描述     -o custom-columns=\u0026lt;spec\u0026gt; 使用逗号分隔的自定义列列表打印表。   -o custom-columns-file=\u0026lt;filename\u0026gt; 使用 \u0026lt;filename\u0026gt; 文件中的自定义列模板打印表。   -o json 输出 JSON 格式的 API 对象   -o jsonpath=\u0026lt;template\u0026gt; 打印 jsonpath 表达式定义的字段   -o jsonpath-file=\u0026lt;filename\u0026gt; 打印 \u0026lt;filename\u0026gt; 文件中 jsonpath 表达式定义的字段。   -o name 仅打印资源名称而不打印任何其他内容。   -o wide 以纯文本格式输出，包含任何附加信息。   -o yaml 输出 YAML 格式的 API 对象。    自定义列   内联\n1  kubectl get pods \u0026lt;pod-name\u0026gt; -o custom-columns=NAME:.metadata.name,RSRC:.metadata.resourceVersion     模版文件\n1 2 3 4 5  kubectl get pods \u0026lt;pod-name\u0026gt; -o custom-columns-file=template.txt # cat template.txt NAME RSRC metadata.name metadata.resourceVersion     排序列表对象 通过使用 \u0026ndash;sort-by 参数指定任何数字或字符串字段来对对象进行排序。要指定字段，请使用jsonpath表达式。\n1  kubectl [command] [TYPE] [NAME] --sort-by=\u0026lt;jsonpath_exp\u0026gt;   按名称排序的pod列表\n1  kubectl get pods --sort-by=.metadata.name   kubectl命令  kubectl command doc: https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands\n 常用操作指南   批量删除\n1 2  # 批量删除状态为Terminating的pod kubectl get pod -A | awk \u0026#39;{if($4==\u0026#34;Terminating\u0026#34;){cmd=\u0026#34;kubectl -n \u0026#34;$1\u0026#34; delete pod \u0026#34;$2; system(cmd)}}\u0026#39;     端口转发\n1 2 3  kubectl port-forward svc/$service_name $local_port:$pod_port --address 0.0.0.0 # 示例 k port-forward service/minio 29001:9001 -n minio --address 0.0.0.0 # 127.0.0.1:29001     平滑移除节点\n1 2 3 4 5 6 7 8 9 10 11 12  # 1.获取需要移除的节点 kubectl get nodes # 2.设置节点为不可调度 ## 由于节点目前处于正常工作状态，集群中新建资源还是有可能创建到该节点的，所以先将节点设置为不可调度 kubectl cordon $node_name # 3.将此节点资源调度到其他节点 ## 目前集群已经不会分配新的资源在该节点上，但是节点还运行着现有的业务，所以需要将节点上的业务分配到其他节点 kubectl drain $node_name # 注意：DaemonSet Pod 和 Static Pod 是不会在集群中其他节点重建的。 # 4.移除节点 ## 集群中已经没有任何资源分配在节点上了，那么我们可以直接移除节点 kubectl delete $node_name     删除不了处于Terminating状态的Pod\n在节点处于“不可用”状态时，CCE会迁移节点上的容器实例，并将节点上运行的pod置为“Terminating”状态。待节点恢复后，处于“Terminating”状态的pod会自动删除。\n偶现部分pod（实例）一直处于“Terminating ”状态\n1 2  # 无论各种方式生成的pod，均可以使用如下命令强制删除 kubectl delete pods \u0026lt;pod\u0026gt; --grace-period=0 --force     删除不了处于Terminating状态的pv,pvc\n1 2 3 4  # 删除pv,pvc步骤：先删pod再删pvc最后删pv。如果遇到pv始终处于“Terminating”状态，而且delete不掉。 ## 直接删除k8s中的记录 kubectl patch pv $pv_name -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;:null}}\u0026#39; kubectl patch pvc $pvc_name -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;finalizers\u0026#34;:null}}\u0026#39;     node标签操作\n1 2 3 4 5 6  # node添加标签 kubectl label nodes $node_name key=value # node删除标签 kubectl label nodes $node_name key- # 根据标签查询节点 kubectl get node -a -l \u0026#34;key=value\u0026#34;     扩缩容\n1 2  kubectl scale deployment $deployment_name --replicas=$count kubectl scale statefulesets $statefulesets_name --replicas=$count     ","description":"Kubectl 命令行工具管理 Kubernetes 集群","id":9,"section":"posts","tags":["kubectl"],"title":"kubectl命令详解","uri":"https://ibora.evcoder.com/posts/kuberneteskubectl%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"},{"content":"kafka简介 Kafka是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的基于发布订阅模式的消息引擎系统。\nkafka本质是一个MQ，MQ的优势：\n 解耦：允许我们独立的扩展或修改队列两边的处理过程。 可恢复性：即使一个处理消息的进程挂掉，加入队列中的消息仍然可以在系统恢复后被处理。 缓冲：有助于解决生产消息和消费消息的处理速度不一致的情况。 灵活性\u0026amp;峰值处理能力：不会因为突发的超负荷的请求而完全崩溃，消息队列能够使关键组件顶住突发的访问压力。 异步通信：消息队列允许用户把消息放入队列但不立即处理它。  Kafka 的特性  高吞吐、低延迟：kakfa 最大的特点就是收发消息非常快，kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒。 高伸缩性： 每个topic包含多个partition，主题中的分区可以分布在不同的broker中。 持久性、可靠性： Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，Kafka 底层的数据存储是基于 Zookeeper 存储的，Zookeeper 我们知道它的数据能够持久存储。 容错性： 允许集群中的节点失败，某个节点宕机，Kafka 集群能够正常工作 高并发： 支持数千个客户端同时读写  kafka基本概念  Producer： 向主题发布消息的客户端应用程序称为生产者，生产者用于持续不断的向某个主题发送消息。 Consumer： 订阅主题消息的客户端程序称为消费者，消费者用于处理生产者产生的消息。 Consumer Group： 消费者组（CG），消费者组内每个消费者负责消费不同分区的数据，提高消费能力。一个分区只能由组内一个消费者消费，消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。 Broker： 一台 Kafka 机器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。 Topic： 可以理解为一个队列，topic 将消息分类，生产者和消费者面向的是同一个 topic。 Partition： 为了实现扩展性，提高并发能力，一个非常大的topic可以分布到多个 broker上，一个 topic 可以分为多个 partition，每个partition是一个有序的队列。 **Replica：**副本，为实现备份的功能，保证集群中的某个节点发生故障时，该节点上的 partition 数据不丢失，且 Kafka 仍然能够继续工作，Kafka 提供了副本机制，一个 topic 的每个分区都有若干个副本，一个 leader 和若干个 follower。 Leader： 每个分区多个副本的“主”副本，生产者发送数据的对象，以及消费者消费数据的对象，都是 leader。 Follower： 每个分区多个副本的“从”副本，实时从 leader 中同步数据，保持和 leader 数据的同步。leader 发生故障时，某个 follower 还会成为新的 leader。 offset： 消费者消费的位置信息，监控数据消费到什么位置，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。 **Zookeeper：**zookeeper 帮助 Kafka 存储和管理集群信息。  kafka架构图 Kafka 的使用场景  活动跟踪：Kafka 可以用来跟踪用户行为。 传递消息：应用程序向用户发送通知就是通过传递消息来实现的，这些应用组件可以生成消息，而不需要关心消息的格式，也不需要关心消息是如何发送的。 度量指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反馈，比如报警和报告。 日志记录：Kafka 的基本概念来源于提交日志，比如我们可以把数据库的更新发送到 Kafka 上，用来记录数据库的更新时间，通过kafka以统一接口服务的方式开放给各种consumer，例如hadoop、Hbase、Solr等。 流式处理：流式处理是有一个能够提供多种应用程序的领域。 限流削峰：Kafka 多用于互联网领域某一时刻请求特别多的情况下，可以把请求写入Kafka 中，避免直接请求后端程序导致服务崩溃。  kafka系列博客列表  kafka集群部署  helm部署kafka集群   kafka命令行详解  ","description":"kafka系列文章","id":11,"section":"posts","tags":["系列"],"title":"kafka系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97kafka%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"kubectl get pod -n enigma2 |grep -E \u0026quot;xfs|kms|accountx|fuwu-api|download|data-service|fuwu-runner|notification|dataset|fednodex|fedapp|workspace|workflow-api|enigma2-dockerunner|project-api\u0026quot;|grep -v \u0026quot;Completed\u0026quot;|awk '{print $1}'|xargs kubectl delete pod -n enigma2 kubectl get pod -n csi-basebit -owide|grep csi|awk '{print $1}'|xargs kubectl delete pod -n csi-basebit ","description":"postgresql系列文章","id":13,"section":"posts","tags":["系列"],"title":"postgresql系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97postgresql%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"mysql简介 MySQL是一个小型的开源的关系型数据库管理系统，MySQL规模小，功能有限，但是它体积小、速度快、成本低，且它提供的功能对稍微复杂的应用已经够用，这些特性使得MySQL成为世界上最受欢迎的开放源代码数据库。\nMySQL是一种开放源代码的关系型数据库管理系统（RDBMS），MySQL数据库系统使用最常用的数据库管理语言——结构化查询语言（SQL）进行数据库管理。\nmysql系列博客列表 ","description":"mysql系列文章","id":16,"section":"posts","tags":["系列"],"title":"mysql系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97mysql%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":" git 官网： https://git-scm.com/\n git简介 Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\nGit是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\ngit系列博客列表  git远程仓库  gitlab github  github package详解      ","description":"git系列文章","id":18,"section":"posts","tags":["系列"],"title":"git系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97git%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"traefik简介 Traefik 是一款 边缘路由器，可让您轻松地发布服务. 它接收来自您的系统请求，并找出负责处理它们的后端服务组件。\ntraefik 与众不同在于它能够自动发现适合您服务的配置。 当 Traefik 检查您的基础设施时，它会发现相关信息，并发现哪个服务服务于哪个请求。\nTraefik 支持多种集群技术，如 Kubernetes，Kubernetes, Docker, Docker Swarm, AWS, Mesos, Marathon; 并且可以同时处理多个 providers。\n使用 Traefik，无需维护和同步配置文件：所有操作都会自动实时完成（无重启，不用中断服务）。 使用 Traefik，您只需花时间于系统开发和部署新功能，而不是配置和维护其工作状态。\ntraefik系列博客列表 ","description":"traefik系列文章","id":27,"section":"posts","tags":["系列"],"title":"traefik系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97traefik%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"terraform简介 Terraform 是一种安全有效地构建、更改和版本控制基础设施的工具(基础架构自动化的编排工具)。它的目标是 \u0026ldquo;Write, Plan, and create Infrastructure as Code\u0026rdquo;, 基础架构即代码。Terraform 几乎可以支持所有市面上能见到的云服务。具体的说就是可以用代码来管理维护 IT 资源，把之前需要手动操作的一部分任务通过程序来自动化的完成，这样的做的结果非常明显：高效、不易出错。\nTerraform 提供了对资源和提供者的灵活抽象。该模型允许表示从物理硬件、虚拟机和容器到电子邮件和 DNS 提供者的所有内容。由于这种灵活性，Terraform 可以用来解决许多不同的问题。这意味着有许多现有的工具与Terraform 的功能重叠。但是需要注意的是，Terraform 与其他系统并不相互排斥。它可以用于管理小到单个应用程序或达到整个数据中心的不同对象。\nTerraform 使用配置文件描述管理的组件(小到单个应用程序，达到整个数据中心)。Terraform 生成一个执行计划，描述它将做什么来达到所需的状态，然后执行它来构建所描述的基础结构。随着配置的变化，Terraform 能够确定发生了什么变化，并创建可应用的增量执行计划。\nterraform核心功能 基础架构即代码(Infrastructure as Code)\n使用高级配置语法来描述基础架构，这样就可以对数据中心的蓝图进行版本控制，就像对待其他代码一样对待它。\n执行计划(Execution Plans)\nTerraform 有一个 plan 步骤，它生成一个执行计划。执行计划显示了当执行 apply 命令时 Terraform 将做什么。通过 plan 进行提前检查，可以使 Terraform 操作真正的基础结构时避免意外。\n资源图(Resource Graph)\nTerraform 构建的所有资源的图表，它能够并行地创建和修改任何没有相互依赖的资源。因此，Terraform 可以高效地构建基础设施，操作人员也可以通过图表深入地解其基础设施中的依赖关系。\n自动化变更(Change Automation)\n把复杂的变更集应用到基础设施中，而无需人工交互。通过前面提到的执行计划和资源图，我们可以确切地知道 Terraform 将会改变什么，以什么顺序改变，从而避免许多可能的人为错误。\nterrform系列博客列表  terraform安装 terraform概念详解 terraform语法详解 terraform命令行详解  ","description":"terraform系列文章","id":28,"section":"posts","tags":["系列"],"title":"terraform系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97terraform%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"golang简介 go语言（或 Golang）是Google开发的开源编程语言，诞生于2006年1月2日，于2009年11月开源，2012年发布go稳定版。Go语言在多核并发上拥有原生的设计优势，Go语言从底层原生支持并发，无须第三方库、开发者的编程技巧和开发经验。\ngolang系列博客列表  golang语法 golang标准库 golang三方库 golang爬虫 golang web框架 golang微服务框架  ","description":"golang系列文章","id":37,"section":"posts","tags":["系列"],"title":"golang系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97golang%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"prometheus简介 ","description":"prometheus系列文章","id":40,"section":"posts","tags":["系列"],"title":"prometheus系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97prometheus%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"kubernetes简介 Kubernetes 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。该项目托管在CNCF。\nKubernetes 这个名字源于希腊语，意为“舵手”或“飞行员”。k8s 这个缩写是因为 k 和 s 之间有八个字符的关系。 Google 在 2014 年开源了 Kubernetes 项目。是 Google 多年大规模容器管理技术 Borg 的开源版本，结合了社区中最好的想法和实践。\nkubernetes功能：\n  服务发现和负载均衡\nKubernetes 可以使用 DNS 名称或自己的 IP 地址公开容器，如果进入容器的流量很大， Kubernetes 可以负载均衡并分配网络流量，从而使部署稳定。\n  存储编排\nKubernetes 允许你自动挂载你选择的存储系统，例如本地存储、公共云提供商等。\n  自动部署和回滚\n你可以使用 Kubernetes 描述已部署容器的所需状态，它可以以受控的速率将实际状态 更改为期望状态。例如，你可以自动化 Kubernetes 来为你的部署创建新容器， 删除现有容器并将它们的所有资源用于新容器。\n  自动完成装箱计算\nKubernetes 允许你指定每个容器所需 CPU 和内存（RAM）。 当容器指定了资源请求时，Kubernetes 可以做出更好的决策来管理容器的资源。\n  自我修复\nKubernetes 重新启动失败的容器、替换容器、杀死不响应用户定义的 运行状况检查的容器，并且在准备好服务之前不将其通告给客户端。\n  密钥与配置管理\nKubernetes 允许你存储和管理敏感信息，例如密码、OAuth 令牌和 ssh 密钥。 你可以在不重建容器镜像的情况下部署和更新密钥和应用程序配置，也无需在堆栈配置中暴露密钥。\n  kubernetes系列博客列表   kubernetes部署\n minikube安装kubernetes集群 kind安装kubernetes集群 kubeadm安装kubernetes集群 kubespray安装kubernetes集群 sealos安装kubernetes集群    kubernetes管理工具\n rancher  rancher部署文档   kubesphere    kubernetes架构\n  kubernetes核心组件\n etcd kube-apiserver kube-scheduler kube-controller-manager kubelet kube-proxy    kubernetes附加组件\n CoreDns    kubernetes网络插件\n CNI flannel calico    kubernetes资源对象\n kubernetes CustomResourceDefinition详解 kubernetes ConfigMap详解 kubernetes CronJob详解 kubernetes DaemonSet详解 kubernetes Deployment详解 kubernetes Ingress详解 kubernetes Job详解 kubernetes LocalValume详解 kubernetes Namespace详解 kubernetes NetworkPolicy详解 kubernetes Node详解 kubernetes PersistentVolume详解 kubernetes Pod详解 kubernetes PodPreset详解 kubernetes RelicaSet详解 kubernetes Quota详解 kubernetes Secret详解 kubernetes SecurityContext详解 kubernetes Service详解 kubernetes ServiceAccount详解 kubernetes StatefulSet详解 kubernetes Volume详解    kubernetes命令行工具\n kubectl命令详解 kubectx命令详解 kubens命令详解 kubecm命令详解    ","description":"kubernetes系列文章","id":43,"section":"posts","tags":["系列"],"title":"kubernetes系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97kubernetes%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":"openstack简介  openstack官网: https://www.openstack.org/\nopenstack gitHub: https://github.com/openstack\n OpenStack是一个云操作系统，通过数据中心可控制大型的计算、存储、网络等资源池。所有的管理通过前端界面管理员就可以完成，同样也可以通过web接口让最终用户部署资源。\nOpenStack系统由几个关键服务组成，它们可以单独安装。这些服务根据你的云需求工作在一起。这些服务包括计算服务、认证服务、网络服务、镜像服务、块存储服务、对象存储服务、计量服务、编排服务和数据库服务。您可以独立安装这些服务、独自配置它们或者连接成一个整体。\nopenstack组件    服务 组件名称 描述     dashboard horizon 提供了一个基于web的自服务门户，与OpenStack底层服务交互，诸如启动一个实例，分配IP地址以及配置访问控制。   计算 nova 在OpenStack环境中计算实例的生命周期管理。按需响应包括生成、调度、回收虚拟机等操作。   网络 neutron 确保为其它OpenStack服务提供网络连接即服务，比如OpenStack计算。为用户提供API定义网络和使用。基于插件的架构其支持众多的网络提供商和技术。   对象存储 swift 通过一个 RESTful,基于HTTP的应用程序接口存储和任意检索的非结构化数据对象。它拥有高容错机制，基于数据复制和可扩展架构。它的实现并像是一个文件服务器需要挂载目录。在此种方式下，它写入对象和文件到多个硬盘中，以确保数据是在集群内跨服务器的多份复制。   块存储 cinder 为运行实例而提供的持久性块存储。它的可插拔驱动架构的功能有助于创建和管理块存储设备。   身份服务 keystone 为其他OpenStack服务提供认证和授权服务，为所有的OpenStack服务提供一个端点目录。   镜像服务 glance 存储和检索虚拟机磁盘镜像，OpenStack计算会在实例部署时使用此服务。   遥测服务 Ceilometer 为OpenStack云的计费、基准、扩展性以及统计等目的提供监测和计量。   编排服务 Heat 既可以使用本地模板格式，亦可使用AWS CloudFormation模板格式，来编排多个综合的云应用，通过OpenStack本地REST API或者是CloudFormation相兼容的队列API。    openstack系列博客列表  openstack部署  Openstack部署文档 kolla部署openstack文档   openstack组件  horizon组件详解 nova组件详解 neutron组件详解 swift组件详解 cinder组件详解 keystone组件详解 glance组件详解 ceilometer组件详解 heat组件详解   openstack仪表盘 openstack命令行客户端  openstack命令行客户端安装 openstack命令行管理镜像 openstack命令行管理卷 openstack命令行管理共享 openstack命令行设定实例的权限和安全设置 openstack命令行启动云主机 openstack命令行管理实例和主机 openstack命令行为实例提供用户数据 openstack命令行使用快照来迁移实例 openstack命令行在配置驱动上存储元数据 openstack命令行创建和管理网路 openstack命令行创建和管理栈   openstack python SDK  ","description":"openstack系列文章","id":44,"section":"posts","tags":["openstack"],"title":"openstack系列文章","uri":"https://ibora.evcoder.com/posts/%E7%B3%BB%E5%88%97openstack%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/"},{"content":" kolla文档地址： https://docs.openstack.org/kolla-ansible/xena/index.html\nkolla github地址： https://github.com/openstack/kolla\n 1. all-in-one模式 2. Multinode模式 主机配置规划    主机名 网口（nat/bridge） cpu 内存 磁盘 系统     kolla-controller 10.0.0.10/ 4c 8G 40G ubuntu20.04   kolla-compute01 10.0.0.11/ 4c 8G 30G ubuntu20.04   kolla-compute02 10.0.0.12/ 4c 8G 30G ubuntu20.04   kolla-compute03 10.0.0.13/ 4c 8G 30G ubuntu20.04   kolla-storage 10.0.0.14/ 2c 4G 500G ubuntu20.04    初始化环境配置 1.替换镜像源 1 2 3 4 5 6 7 8  # 首先备份源列表--ubuntu20.04 sudo cp /etc/apt/sources.list /etc/apt/sources.list_backup vim /etc/apt/sources.list # 添加ubuntu20.04的配置 https://developer.aliyun.com/mirror/ubuntu?spm=a2c6h.13651102.0.0.3e221b1176Cuex sudo apt upate sudo apt upgrade   2.安装依赖包 1  apt-get install python-dev libffi-dev gcc libssl-dev python-selinux python-setuptools git vim -y   3.安装ansible 1 2 3 4 5 6 7 8  sudo apt install ansible # 配置ansible vim /etc/ansible/ansible.cfg [defaults] host_key_checking=False pipelining=True forks=100   4.安装kolla-ansible 1 2 3 4 5 6 7 8 9  # 下载安装包 git clone --branch stable/xena https://opendev.org/openstack/kolla-ansible sudo pip3 install ./kolla-ansible # 创建kolla配置文件目录 sudo mkdir -p /etc/kolla sudo chown $USER:$USER /etc/kolla cp -r kolla-ansible/etc/kolla/* /etc/kolla cp kolla-ansible/ansible/inventory/* .   5.修改配置文件 6.检查库文件配置是否正确 ansible -i multinode all -m ping 7.生成密码 1 2  cd kolla-ansible/tools ./generate_passwords.py   ","description":"kolla部署openstack","id":45,"section":"posts","tags":["openstack"],"title":"kolla部署openstack文档","uri":"https://ibora.evcoder.com/posts/openstackkolla%E9%83%A8%E7%BD%B2openstack%E6%96%87%E6%A1%A3/"},{"content":"环境准备 1 2 3 4 5  package main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;hello world!!!!\u0026#34;) }   初始化 ","description":"openstack 部署手册","id":46,"section":"posts","tags":["openstack"],"title":"Openstack部署文档","uri":"https://ibora.evcoder.com/posts/openstackopenstack%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/"},{"content":"图册收集\n","description":"photo gallery","id":48,"section":"","tags":null,"title":"图册","uri":"https://ibora.evcoder.com/gallery/"}]